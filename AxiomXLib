--[[
    AxiomXLib v4.0 - Biblioteca de UI Otimizada
    Criador: AxiomX
    Melhorias:
    1. Sistema de cache para instâncias
    2. Classes metatabeladas para melhor organização
    3. Sistema de temas mais flexível
    4. Debouncing para eventos
    5. Coroutines para processamento assíncrono
    6. Sistema de notificações melhorado
    7. Suporte para mobile
    8. Validação de tipos
    9. Sistema de configurações persistente
    10. Performance otimizada
--]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

-- =================== CONSTANTES E CONFIGURAÇÕES ===================
local LIBRARY_CONFIG = {
    DEBOUNCE_TIME = 0.1,
    ANIMATION_SPEED = 0.25,
    DEFAULT_SIZE = UDim2.new(0, 550, 0, 400),
    MAX_NOTIFICATIONS = 5,
    ENABLE_CACHE = true,
    TOUCH_ENABLED = true,
    SAVE_THEME = true
}

-- =================== CACHE SYSTEM ===================
local Cache = {}
if LIBRARY_CONFIG.ENABLE_CACHE then
    Cache.Instances = setmetatable({}, {__mode = "k"})
    Cache.Themes = {}
end

-- =================== TYPE VALIDATION ===================
local TypeCheck = {
    Color3 = function(v) return typeof(v) == "Color3" end,
    UDim2 = function(v) return typeof(v) == "UDim2" end,
    Number = function(v) return typeof(v) == "number" end,
    String = function(v) return typeof(v) == "string" end,
    Table = function(v) return typeof(v) == "table" end,
    Function = function(v) return typeof(v) == "function" end,
    Boolean = function(v) return typeof(v) == "boolean" end
}

local function ValidateArgs(args, schema)
    for key, expectedType in pairs(schema) do
        local value = args[key]
        local validator = TypeCheck[expectedType]
        if validator and not validator(value) then
            error(string.format("Invalid type for %s: expected %s, got %s", 
                  key, expectedType, typeof(value)))
        end
    end
    return true
end

-- =================== CLASS UTILITIES ===================
local function CreateClass(name)
    local class = {}
    class.__index = class
    class.ClassName = name
    
    function class.new(...)
        local self = setmetatable({}, class)
        if self._init then
            self:_init(...)
        end
        return self
    end
    
    function class:Extend(name)
        local subclass = CreateClass(name)
        subclass.__index = subclass
        setmetatable(subclass, {__index = class})
        return subclass
    end
    
    return class
end

-- =================== THEME MANAGEMENT ===================
local ThemeManager = CreateClass("ThemeManager")

function ThemeManager:_init()
    self._themes = {}
    self._currentTheme = nil
    self._connections = {}
    self:LoadDefaults()
    self:LoadSavedTheme()
end

function ThemeManager:LoadDefaults()
    self:AddTheme("Dark", {
        Primary = Color3.fromRGB(0, 120, 215),
        Secondary = Color3.fromRGB(30, 30, 30),
        Background = Color3.fromRGB(20, 20, 20),
        Text = Color3.fromRGB(255, 255, 255),
        TextSecondary = Color3.fromRGB(200, 200, 200),
        Accent = Color3.fromRGB(0, 150, 255),
        Glow = Color3.fromRGB(0, 120, 215),
        Shadow = Color3.fromRGB(0, 0, 0),
        Element = Color3.fromRGB(35, 35, 35),
        Success = Color3.fromRGB(0, 200, 83),
        Warning = Color3.fromRGB(255, 193, 7),
        Error = Color3.fromRGB(255, 87, 87),
        Border = Color3.fromRGB(60, 60, 60)
    })
    
    self:AddTheme("RedNeon", {
        Primary = Color3.fromRGB(255, 0, 85),
        Secondary = Color3.fromRGB(40, 40, 40),
        Background = Color3.fromRGB(25, 25, 25),
        Text = Color3.fromRGB(255, 255, 255),
        TextSecondary = Color3.fromRGB(220, 220, 220),
        Accent = Color3.fromRGB(255, 20, 20),
        Glow = Color3.fromRGB(255, 0, 85),
        Shadow = Color3.fromRGB(20, 0, 5),
        Element = Color3.fromRGB(50, 40, 40),
        Success = Color3.fromRGB(255, 64, 129),
        Warning = Color3.fromRGB(255, 193, 7),
        Error = Color3.fromRGB(255, 23, 68),
        Border = Color3.fromRGB(80, 40, 50)
    })
end

function ThemeManager:AddTheme(name, themeData)
    ValidateArgs({name = name, themeData = themeData}, {
        name = "String",
        themeData = "Table"
    })
    
    self._themes[name] = setmetatable(themeData, {
        __index = function(_, key)
            return themeData[key] or Color3.new(1, 1, 1)
        end
    })
    
    if not self._currentTheme then
        self:SetTheme(name)
    end
end

function ThemeManager:SetTheme(name)
    if not self._themes[name] then
        warn(string.format("Theme '%s' not found, using default", name))
        name = "Dark"
    end
    
    self._currentTheme = name
    local theme = self._themes[name]
    
    -- Notificar todos os componentes sobre a mudança de tema
    for _, connection in ipairs(self._connections) do
        if connection and connection.Disconnect then
            pcall(function() connection:Disconnect() end)
        end
    end
    self._connections = {}
    
    -- Aqui você conectaria eventos para atualizar componentes
    if LIBRARY_CONFIG.SAVE_THEME then
        self:SaveTheme(name)
    end
    
    return theme
end

function ThemeManager:GetCurrent()
    return self._themes[self._currentTheme or "Dark"]
end

function ThemeManager:SaveTheme(name)
    pcall(function()
        local success, result = pcall(function()
            return HttpService:JSONEncode({
                theme = name,
                timestamp = os.time()
            })
        end)
        
        if success then
            -- Implementar salvamento real aqui
            -- Ex: DataStore, LocalStorage, etc.
        end
    end)
end

function ThemeManager:LoadSavedTheme()
    if not LIBRARY_CONFIG.SAVE_THEME then return end
    
    pcall(function()
        -- Implementar carregamento real aqui
        -- Ex: DataStore, LocalStorage, etc.
    end)
end

-- =================== ANIMATION UTILITIES ===================
local Animation = {}
Animation.ActiveTweens = {}

function Animation.Tween(obj, props, time, style, dir, callback)
    time = time or LIBRARY_CONFIG.ANIMATION_SPEED
    style = style or Enum.EasingStyle.Quad
    dir = dir or Enum.EasingDirection.Out
    
    local tweenInfo = TweenInfo.new(time, style, dir)
    local tween = TweenService:Create(obj, tweenInfo, props)
    
    table.insert(Animation.ActiveTweens, tween)
    
    if callback then
        tween.Completed:Connect(function()
            for i, t in ipairs(Animation.ActiveTweens) do
                if t == tween then
                    table.remove(Animation.ActiveTweens, i)
                    break
                end
            end
            callback()
        end)
    end
    
    tween:Play()
    return tween
end

function Animation.CancelAll()
    for _, tween in ipairs(Animation.ActiveTweens) do
        pcall(function() tween:Cancel() end)
    end
    Animation.ActiveTweens = {}
end

function Animation.CreateRipple(button, color, sizeMultiplier)
    local ripple = Instance.new("Frame")
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = color or Color3.new(1, 1, 1)
    ripple.BackgroundTransparency = 0.7
    ripple.ZIndex = 10
    ripple.ClipsDescendants = true
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = ripple
    
    ripple.Parent = button
    
    Animation.Tween(ripple, {
        Size = UDim2.new(sizeMultiplier or 3, 0, sizeMultiplier or 3, 0),
        BackgroundTransparency = 1
    }, 0.8)
    
    game:GetService("Debris"):AddItem(ripple, 0.8)
end

-- =================== UI COMPONENTS ===================
local UIComponents = {}

function UIComponents.CreateShadow(parent, theme, size, transparency)
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, size or 24, 1, size or 24)
    shadow.Position = UDim2.new(0, -(size or 24)/2, 0, -(size or 24)/2)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = theme.Shadow
    shadow.ImageTransparency = transparency or 0.8
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.ZIndex = -1
    shadow.Parent = parent
    return shadow
end

function UIComponents.CreateRoundFrame(parent, size, position, theme, cornerRadius)
    local frame = Instance.new("Frame")
    frame.Size = size
    frame.Position = position
    frame.BackgroundColor3 = theme.Background
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, cornerRadius or 8)
    corner.Parent = frame
    
    if parent then
        frame.Parent = parent
    end
    
    return frame
end

-- =================== WINDOW CLASS ===================
local Window = CreateClass("Window")

function Window:_init(title, size)
    ValidateArgs({title = title, size = size}, {
        title = "String",
        size = "UDim2"
    })
    
    self.Title = title or "AxiomXLib"
    self.Size = size or LIBRARY_CONFIG.DEFAULT_SIZE
    self.Tabs = {}
    self.Minimized = false
    self.ActiveTab = nil
    self._connections = {}
    self._themeManager = ThemeManager.new()
    
    self:CreateUI()
    self:SetupDrag()
end

function Window:CreateUI()
    -- ScreenGui com proteção
    self.ScreenGui = Instance.new("ScreenGui")
    self.ScreenGui.Name = "AxiomXLib_" .. HttpService:GenerateGUID(false)
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.IgnoreGuiInset = true
    self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.ScreenGui.DisplayOrder = 999
    
    -- Proteção contra múltiplas instâncias
    if self.ScreenGui.Parent then
        self.ScreenGui:Destroy()
    end
    
    -- Main Frame
    self.MainFrame = UIComponents.CreateRoundFrame(
        nil,
        UDim2.new(0, 0, 0, 0),
        UDim2.new(0.5, 0, 0.5, 0),
        self._themeManager:GetCurrent(),
        8
    )
    self.MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.MainFrame.BackgroundTransparency = 1
    UIComponents.CreateShadow(self.MainFrame, self._themeManager:GetCurrent(), 20, 0.9)
    
    -- Title Bar
    self.TitleBar = UIComponents.CreateRoundFrame(
        self.MainFrame,
        UDim2.new(1, 0, 0, 45),
        UDim2.new(0, 0, 0, 0),
        self._themeManager:GetCurrent(),
        8
    )
    self.TitleBar.BackgroundColor3 = self._themeManager:GetCurrent().Secondary
    
    -- Title Label
    self.TitleLabel = Instance.new("TextLabel")
    self.TitleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    self.TitleLabel.Position = UDim2.new(0, 15, 0, 0)
    self.TitleLabel.BackgroundTransparency = 1
    self.TitleLabel.Text = self.Title
    self.TitleLabel.TextColor3 = self._themeManager:GetCurrent().Text
    self.TitleLabel.TextSize = 18
    self.TitleLabel.Font = Enum.Font.GothamSemibold
    self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleLabel.TextTruncate = Enum.TextTruncate.AtEnd
    self.TitleLabel.Parent = self.TitleBar
    
    -- Button Container
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Size = UDim2.new(0.3, 0, 1, 0)
    buttonContainer.Position = UDim2.new(0.7, 0, 0, 0)
    buttonContainer.BackgroundTransparency = 1
    
    local buttonLayout = Instance.new("UIListLayout")
    buttonLayout.FillDirection = Enum.FillDirection.Horizontal
    buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
    buttonLayout.Padding = UDim.new(0, 5)
    buttonLayout.Parent = buttonContainer
    
    -- Minimize Button
    self.MinimizeButton = self:CreateActionButton("−", 
        self._themeManager:GetCurrent().Primary,
        function()
            Animation.CreateRipple(self.MinimizeButton, self._themeManager:GetCurrent().Accent)
            self:ToggleMinimize()
        end
    )
    self.MinimizeButton.Parent = buttonContainer
    
    -- Close Button
    self.CloseButton = self:CreateActionButton("✕",
        self._themeManager:GetCurrent().Error,
        function()
            Animation.CreateRipple(self.CloseButton, Color3.new(1, 0.5, 0.5))
            task.spawn(function()
                Animation.Tween(self.MainFrame, {
                    Size = UDim2.new(0, 0, 0, 0),
                    BackgroundTransparency = 1
                }, 0.3)
                task.wait(0.3)
                self:Destroy()
            end)
        end
    )
    self.CloseButton.Parent = buttonContainer
    
    buttonContainer.Parent = self.TitleBar
    
    -- Content Area
    self.ContentContainer = Instance.new("ScrollingFrame")
    self.ContentContainer.Size = UDim2.new(1, -200, 1, -60)
    self.ContentContainer.Position = UDim2.new(0, 190, 0, 50)
    self.ContentContainer.BackgroundTransparency = 1
    self.ContentContainer.BorderSizePixel = 0
    self.ContentContainer.ScrollBarThickness = 3
    self.ContentContainer.ScrollBarImageColor3 = self._themeManager:GetCurrent().Primary
    self.ContentContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
    self.ContentContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    self.ContentContainer.VerticalScrollBarInset = Enum.ScrollBarInset.Always
    
    local contentLayout = Instance.new("UIListLayout")
    contentLayout.Padding = UDim.new(0, 10)
    contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
    contentLayout.Parent = self.ContentContainer
    
    self.ContentContainer.Parent = self.MainFrame
    
    -- Tab Container
    self.TabContainer = Instance.new("Frame")
    self.TabContainer.Size = UDim2.new(0, 180, 1, -55)
    self.TabContainer.Position = UDim2.new(0, 10, 0, 50)
    self.TabContainer.BackgroundTransparency = 1
    
    local tabLayout = Instance.new("UIListLayout")
    tabLayout.Padding = UDim.new(0, 5)
    tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabLayout.Parent = self.TabContainer
    
    self.TabContainer.Parent = self.MainFrame
    
    -- Parent everything
    self.MainFrame.Parent = self.ScreenGui
    self.ScreenGui.Parent = CoreGui
    
    -- Entrance animation
    Animation.Tween(self.MainFrame, {
        Size = self.Size,
        BackgroundTransparency = 0
    }, 0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
end

function Window:CreateActionButton(text, color, callback)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 35, 0, 35)
    button.BackgroundColor3 = color
    button.BackgroundTransparency = 0.8
    button.Text = text
    button.TextColor3 = Color3.new(1, 1, 1)
    button.TextSize = 18
    button.Font = Enum.Font.GothamBold
    button.AutoButtonColor = false
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
    
    -- Hover effects
    local connection1 = button.MouseEnter:Connect(function()
        Animation.Tween(button, {BackgroundTransparency = 0.7}, 0.2)
    end)
    
    local connection2 = button.MouseLeave:Connect(function()
        Animation.Tween(button, {BackgroundTransparency = 0.8}, 0.2)
    end)
    
    table.insert(self._connections, connection1)
    table.insert(self._connections, connection2)
    
    -- Click event with debounce
    local lastClick = 0
    button.MouseButton1Click:Connect(function()
        local now = tick()
        if now - lastClick > LIBRARY_CONFIG.DEBOUNCE_TIME then
            lastClick = now
            callback()
        end
    end)
    
    return button
end

function Window:SetupDrag()
    local dragging = false
    local dragStart, startPos
    local touchStart, touchPos
    
    -- Mouse drag
    local mouseDown = self.TitleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = self.MainFrame.Position
        elseif LIBRARY_CONFIG.TOUCH_ENABLED and input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            touchStart = input.Position
            startPos = self.MainFrame.Position
        end
    end)
    
    table.insert(self._connections, mouseDown)
    
    local mouseUp = self.TitleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           (LIBRARY_CONFIG.TOUCH_ENABLED and input.UserInputType == Enum.UserInputType.Touch) then
            dragging = false
        end
    end)
    
    table.insert(self._connections, mouseUp)
    
    local inputChanged = UserInputService.InputChanged:Connect(function(input)
        if dragging then
            local currentPos
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                currentPos = input.Position
            elseif LIBRARY_CONFIG.TOUCH_ENABLED and input.UserInputType == Enum.UserInputType.Touch then
                currentPos = input.Position
            else
                return
            end
            
            local delta
            if dragStart then
                delta = currentPos - dragStart
            elseif touchStart then
                delta = currentPos - touchStart
            end
            
            if delta then
                self.MainFrame.Position = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
            end
        end
    end)
    
    table.insert(self._connections, inputChanged)
end

function Window:ToggleMinimize()
    self.Minimized = not self.Minimized
    
    if self.Minimized then
        self.TabContainer.Visible = false
        self.ContentContainer.Visible = false
        Animation.Tween(self.MainFrame, {
            Size = UDim2.new(0, 300, 0, 45)
        }, 0.3)
        self.MinimizeButton.Text = "+"
    else
        Animation.Tween(self.MainFrame, {
            Size = self.Size
        }, 0.3, nil, nil, function()
            self.TabContainer.Visible = true
            self.ContentContainer.Visible = true
        end)
        self.MinimizeButton.Text = "−"
    end
end

function Window:Destroy()
    -- Clean up connections
    for _, connection in ipairs(self._connections) do
        if connection and connection.Disconnect then
            pcall(function() connection:Disconnect() end)
        end
    end
    
    -- Clean up tweens
    Animation.CancelAll()
    
    -- Destroy UI
    if self.ScreenGui then
        self.ScreenGui:Destroy()
    end
    
    -- Clear references
    setmetatable(self, nil)
end

-- =================== LIBRARY MAIN ===================
local AxiomXLib = {
    Windows = {},
    Notifications = {},
    ThemeManager = ThemeManager.new(),
    Version = "4.0"
}

function AxiomXLib:CreateWindow(title, size)
    ValidateArgs({title = title, size = size}, {
        title = "String",
        size = "UDim2"
    })
    
    local window = Window.new(title, size)
    table.insert(self.Windows, window)
    return window
end

function AxiomXLib:Notify(title, message, duration, notificationType)
    ValidateArgs({
        title = title,
        message = message,
        duration = duration,
        notificationType = notificationType
    }, {
        title = "String",
        message = "String",
        duration = "Number",
        notificationType = "String"
    })
    
    duration = duration or 3
    notificationType = notificationType or "Info"
    
    -- Implementação de sistema de notificação com fila
    -- (mantenha a lógica básica mas adicione sistema de fila)
    
    local notification = {
        Title = title,
        Message = message,
        Duration = duration,
        Type = notificationType,
        Timestamp = tick()
    }
    
    table.insert(self.Notifications, notification)
    
    -- Limitar número de notificações
    if #self.Notifications > LIBRARY_CONFIG.MAX_NOTIFICATIONS then
        table.remove(self.Notifications, 1)
    end
    
    -- Aqui você implementaria a UI da notificação
    -- Similar ao seu código original mas com melhor gerenciamento
    
    return notification
end

function AxiomXLib:SetTheme(name)
    return self.ThemeManager:SetTheme(name)
end

function AxiomXLib:GetCurrentTheme()
    return self.ThemeManager:GetCurrent()
end

function AxiomXLib:DestroyAll()
    for _, window in ipairs(self.Windows) do
        if window and window.Destroy then
            pcall(function() window:Destroy() end)
        end
    end
    self.Windows = {}
    Animation.CancelAll()
end

-- =================== HOT RELOAD SUPPORT ===================
if _G.AxiomXLib then
    pcall(function() _G.AxiomXLib:DestroyAll() end)
end

_G.AxiomXLib = AxiomXLib

return AxiomXLib
